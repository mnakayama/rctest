# Cline Rules

## ロール定義

あなたは Vue3/Nuxt.3 + Supabase のエキスパートエンジニア兼 UI/UX デザイナーとして対応してください。

## 技術スタック

- フロントエンド
  - Vue3 (Composition API) / Nuxt.3
  - TypeScript
  - Pinia
  - Vue Router / Nuxt Router
- バックエンド
  - Supabase
  - Nuxt Server API
- 開発環境
  - Docker
  - Docker Compose
- ユニットテスト
  - Vitest
  - Nuxt Test Utils
  - Playwright (E2E)
- フォーマッター
  - Prettier
  - ESLint
- UI フレームワーク
  - Tailwind CSS
  - daisyUI
- CI/CD
  - GitHub Actions
  - Docker BuildKit

## 開発環境

### Docker設定

1. 開発環境は必ずDocker環境を使用
2. 開発、本番環境用の Dockerfile を分離
3. docker-compose.yml で開発環境の完全な再現性を確保
4. .dockerignore の適切な設定

#### Dockerfile 例

```dockerfile
# 開発環境用 Dockerfile
FROM node:20-alpine AS development

WORKDIR /app

# システム依存関係のインストール
RUN apk add --no-cache \
    git \
    python3 \
    make \
    gcc \
    g++

# パッケージのコピーとインストール
COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile

# アプリケーションコードのコピー
COPY . .

# 開発サーバーの起動
CMD ["yarn", "dev"]
```

#### 本番環境用 Dockerfile

```dockerfile
# 本番環境用 Dockerfile
FROM node:20-alpine AS build

WORKDIR /app

# 依存関係インストール
COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile

# ソースコードをコピー
COPY . .

# アプリケーションをビルド
RUN yarn build

# 本番イメージ
FROM node:20-alpine AS production

WORKDIR /app

# ビルド成果物と必要なファイルのみをコピー
COPY --from=build /app/.output ./.output
COPY --from=build /app/package.json ./package.json

# 依存関係をインストール（本番用）
RUN yarn install --production

# ポート公開
EXPOSE 3000

# サーバー起動
CMD ["node", ".output/server/index.mjs"]
```

### Docker Compose 設定

```yaml
version: '3.8'
services:
  frontend:
    build:
      context: .
      target: development
    volumes:
      - .:/app
      - /app/node_modules
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
    depends_on:
      - supabase
  
  supabase:
    image: supabase/postgres:15.1
    environment:
      - POSTGRES_PASSWORD=your_secure_password
    ports:
      - "5432:5432"
```

### TypeScript設定

#### tsconfig.json 例

```json
{
  "extends": "./.nuxt/tsconfig.json",
  "compilerOptions": {
    "strict": true,
    "skipLibCheck": true,
    "types": [
      "@nuxt/types",
      "@pinia/nuxt",
      "@nuxtjs/i18n",
      "vitest/globals"
    ],
    "paths": {
      "~/*": ["./*"],
      "@/*": ["./*"]
    },
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noImplicitThis": true,
    "alwaysStrict": true
  }
}
```

#### TypeScriptベストプラクティス

1. 型定義ファイルを適切に活用
   ```typescript
   // types/index.ts
   export interface User {
     id: string;
     email: string;
     name: string;
     createdAt: string;
   }
   ```

2. 厳格な型チェックを有効化
3. Utility Typesを活用
   ```typescript
   type UserUpdate = Partial<User>;
   type UserKeys = keyof User;
   ```

4. インターフェイスと型エイリアスの使い分け

## Git ワークフロー (GitHub Flow)

### 1. ブランチ戦略

#### ブランチ命名規則
- `main` - 常にデプロイ可能な状態を維持するプロダクションブランチ
- `feature/[機能名]` - 機能実装用ブランチ
- `bugfix/[バグ内容]` - バグ修正用ブランチ
- `hotfix/[修正内容]` - 緊急修正用ブランチ

#### 禁止事項
- **`main`ブランチでの直接作業禁止**
- **`main`ブランチへの直接pushの禁止**

### 2. 作業フロー

1. 常に最新の`main`ブランチからブランチを作成
   ```bash
   git checkout main
   git pull origin main
   git checkout -b feature/xxx
   ```

2. 開発は必ず各目的のブランチで行う
   - 例: `feature/add-user-registration`
   - 例: `bugfix/fix-login-error`

3. こまめにコミットを行う
   - 1つの論理的な変更ごとにコミット
   - コミットメッセージは簡潔かつ明確に変更内容を記述

4. 定期的にリモートリポジトリにpushする
   ```bash
   git push origin feature/xxx
   ```

5. 作業完了後、Pull Requestを作成
   - レビュー後に`main`ブランチにマージ

### 3. コミットメッセージ規約

#### フォーマット
```
[タイプ]: 変更内容の簡潔な説明 (50文字以内)

より詳細な説明 (オプション、72文字以内で改行)
```

#### タイプ
- `feat:` - 新機能
- `fix:` - バグ修正
- `docs:` - ドキュメントのみの変更
- `style:` - コードの意味に影響しない変更（空白、フォーマット等）
- `refactor:` - バグ修正でも機能追加でもないコード変更
- `perf:` - パフォーマンス向上のための変更
- `test:` - テストの追加・修正
- `chore:` - ビルドプロセスやツールの変更

#### 例
```
feat: ユーザー登録フォームの実装

- メールアドレス検証機能を追加
- パスワード強度チェックを実装
- 登録完了後の確認メール送信機能を追加
```

### 4. Pull Request レビュー

- PRは機能単位で小さく保つ
- PRのタイトルと説明は明確に記述
- コードレビューは最低1名の承認が必要
- CIテストが全て通過していることを確認

### 5. マージとデプロイ

- `main`へのマージ後は自動的にデプロイされるものと考える
- マージされたブランチは削除を推奨

### 6. 緊急修正（Hotfix）プロセス

1. `main`から`hotfix/[修正内容]`ブランチを作成
2. 修正を実装しテスト
3. Pull Requestを経て`main`にマージ

### 7. その他のベストプラクティス

- プッシュ前にローカルテストを実行
- 大きな変更前に関係者と協議
- 定期的に不要なブランチを削除してリポジトリを整理
- セキュリティに関わる情報は絶対にコミットしない
- 機能ブランチは定期的に`main`から最新変更を取り込む
  ```bash
  git checkout feature/xxx
  git fetch origin
  git merge origin/main
  # または
  git rebase origin/main
  ```

## 命名規約 (Naming Conventions)

### 1. 一般的な命名ルール (General Naming Rules)

#### 言語別命名規則 (Language-Specific Naming Conventions)
- TypeScript/Vue:
  - `camelCase`: 変数、関数、メソッド
  - `PascalCase`: クラス、コンポーネント、インターフェース
  - `UPPER_SNAKE_CASE`: 定数

#### 禁止事項 (Prohibited Practices)
- 一文字の変数名の使用を避ける（イテレータのiなど一般的な例外を除く）
- 意味のない省略形の使用を避ける
- 非英語の文字（全角文字）の使用を避ける

### 2. ファイル命名規約 (File Naming Conventions)

#### コンポーネント (Components)
- `PascalCase`で命名
- 機能または目的を明確に表現
- 例:
  - `UserProfileCard.vue`
  - `AuthenticationForm.vue`
  - `ProductListItem.vue`

#### ページコンポーネント (Page Components)
- `PascalCase`で命名し、`Page`サフィックスを付与
- 対応するルートを反映
- 例:
  - `UserProfilePage.vue`
  - `ProductListPage.vue`
  - `DashboardPage.vue`

#### コンポーズ関数 (Composable Functions)
- `use`プレフィックスを使用
- `camelCase`で命名
- 機能を明確に示す
- 例:
  - `useAuthUser.ts`
  - `useFormValidation.ts`
  - `useApiClient.ts`

#### ストア (Pinia Stores)
- `use`プレフィックスと`Store`サフィックス
- `PascalCase`
- 例:
  - `useUserStore.ts`
  - `useCartStore.ts`
  - `useAuthenticationStore.ts`

#### ユーティリティ関数 (Utility Functions)
- 明確で簡潔な名前
- `camelCase`
- 機能を示すプレフィックス/サフィックス
- 例:
  - `formatCurrency.ts`
  - `validateEmail.ts`
  - `generateRandomToken.ts`

#### テストファイル (Test Files)
- テスト対象のファイル名 + `.spec` または `.test`
- 例:
  - `UserProfileCard.spec.ts`
  - `AuthenticationForm.test.ts`

### 3. 変数・関数命名 (Variable and Function Naming)

#### 変数命名 (Variable Naming)
- データ型や用途を反映
- プレフィックス/サフィックスで意味を明確化
- 例:
  - `isLoading`: ブール値
  - `userList`: 配列
  - `maxRetryCount`: 数値
  - `currentUserProfile`: オブジェクト

#### 関数・メソッド命名 (Function/Method Naming)
- 動詞 + 目的語の形式
- 明確な意図を示す
- 例:
  - `fetchUserData()`
  - `validateForm()`
  - `createNewUser()`
  - `updateUserProfile()`

#### イベントハンドラ (Event Handlers)
- `on`プレフィックス
- イベントの動作を示す
- 例:
  - `onSubmit`
  - `onCancel`
  - `onUserLogin`

### 4. 環境変数命名 (Environment Variable Naming)

#### Nuxt環境変数 (Nuxt Environment Variables)
- `NUXT_PUBLIC_`: クライアント側に公開可能な変数
- `NUXT_`: サーバーサイドのみの機密変数
- 大文字 + `SNAKE_CASE`
- 例:
  - `NUXT_PUBLIC_API_URL`
  - `NUXT_DATABASE_SECRET`

### 5. クラス・インターフェース命名 (Class and Interface Naming)

#### インターフェース (Interfaces)
- `I`プレフィックス（オプション）
- `PascalCase`
- 名詞または形容詞
- 例:
  - `IUser`
  - `UserProfile`
  - `Authenticatable`

#### 型エイリアス (Type Aliases)
- インターフェースと同様の規則
- 例:
  - `UserType`
  - `AuthenticationResponse`

### 6. CSS/Tailwind クラス命名 (CSS/Tailwind Class Naming)

#### カスタムクラス (Custom Classes)
- `kebab-case`
- 機能的な名前
- 例:
  - `user-card`
  - `login-form`
  - `primary-button`

### 7. API/エンドポイント命名 (API/Endpoint Naming)

#### RESTfulエンドポイント (RESTful Endpoints)
- 名詞（リソース）+ アクション
- 小文字 + ハイフン
- 例:
  - `/api/users`
  - `/api/products`
  - `/api/user-profile`

### 8. 命名の推奨プラクティス (Naming Best Practices)

- 一貫性を保つ
- 意味のある名前を選ぶ
- 自明でない略語は避ける
- コンテキストに応じた適切な命名
- 読みやすさと理解のしやすさを重視

### 9. 禁止される命名パターン (Forbidden Naming Patterns)

- 絵文字の使用
- 非英語の文字
- 意味のない省略形
- 予約語との衝突
- 特殊文字の使用

この命名規約は、コードの可読性、一貫性、保守性を向上させることを目的としています。プロジェクトの特性に応じて適宜調整してください。

## Vue3/Nuxt3 ベストプラクティス

### Composition API の推奨パターン

#### 1. setup 関数の使い方

```vue
<script setup lang="ts">
// インポート
import { ref, computed, watch, onMounted } from 'vue'
import type { User } from '~/types'

// プロパティ定義
const props = defineProps<{
  userId: string
}>()

// エミット定義
const emit = defineEmits<{
  (e: 'update', user: User): void
  (e: 'delete'): void
}>()

// リアクティブな状態
const user = ref<User | null>(null)
const isLoading = ref(true)
const error = ref<Error | null>(null)

// 算出プロパティ
const fullName = computed(() => {
  if (!user.value) return ''
  return `${user.value.firstName} ${user.value.lastName}`
})

// メソッド
const fetchUser = async () => {
  isLoading.value = true
  try {
    user.value = await fetchUserById(props.userId)
  } catch (err) {
    error.value = err as Error
  } finally {
    isLoading.value = false
  }
}

// ウォッチャー
watch(() => props.userId, fetchUser, { immediate: true })

// ライフサイクルフック
onMounted(() => {
  console.log('Component mounted')
})
</script>
```

#### 2. コンポーザブルの作成と使用

```typescript
// composables/useAuth.ts
import { ref, computed } from 'vue'
import type { User } from '~/types'

export function useAuth() {
  const user = ref<User | null>(null)
  const isAuthenticated = computed(() => !!user.value)
  
  async function login(email: string, password: string) {
    // ログイン実装
  }
  
  function logout() {
    // ログアウト実装
  }
  
  return {
    user,
    isAuthenticated,
    login,
    logout
  }
}
```

#### 3. Provide/Inject パターン

```typescript
// アプリケーション全体で使用する状態の提供
// app.vue
import { provide } from 'vue'
import { createSharedState } from '~/composables/sharedState'

const state = createSharedState()
provide('sharedState', state)

// 子コンポーネントでの使用
// components/ChildComponent.vue
import { inject } from 'vue'
import type { SharedState } from '~/types'

const sharedState = inject<SharedState>('sharedState')
```

### サーバーサイドレンダリング (SSR) の最適化

#### 1. クライアントとサーバーのコード分離

```typescript
// utils/platform.ts
export const isClient = typeof window !== 'undefined'
export const isServer = !isClient

// コンポーネント内での使用
import { isClient } from '~/utils/platform'

if (isClient) {
  // クライアントサイドのみで実行するコード
}
```

#### 2. useAsyncData と useFetch の適切な使用

```typescript
// pages/users/[id].vue
const route = useRoute()
const { data: user } = await useFetch(`/api/users/${route.params.id}`)
```

#### 3. サーバーサイドのみの API 呼び出し

```typescript
// server/api/users/[id].ts
export default defineEventHandler(async (event) => {
  const id = getRouterParam(event, 'id')
  // サーバーサイドのみでデータ取得
  return await getUserFromDatabase(id)
})
```

### パフォーマンス最適化

#### 1. コンポーネントの遅延ロード

```typescript
// 重いコンポーネントを遅延ロード
const HeavyComponent = defineAsyncComponent(() => 
  import('~/components/HeavyComponent.vue')
)
```

#### 2. リスト表示の最適化

```vue
<template>
  <!-- key に一意の ID を使用 -->
  <div v-for="item in items" :key="item.id">
    {{ item.name }}
  </div>
</template>
```

#### 3. メモ化による再計算の防止

```typescript
import { computed } from 'vue'

// 高コストな計算をメモ化
const sortedItems = computed(() => {
  console.log('Expensive sorting operation')
  return [...items.value].sort((a, b) => a.name.localeCompare(b.name))
})
```

### レスポンシブデザインとモバイル対応

#### 1. Tailwind ブレークポイントの活用

```vue
<template>
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
    <!-- コンテンツ -->
  </div>
</template>
```

#### 2. デバイス対応のビューポート設定

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  app: {
    head: {
      viewport: 'width=device-width, initial-scale=1',
      meta: [
        { name: 'theme-color', content: '#ffffff' }
      ]
    }
  }
})
```

#### 3. タッチ操作対応

```vue
<template>
  <div 
    @click="handleClick" 
    @touchstart="handleTouchStart"
    @touchend="handleTouchEnd"
    class="hover:bg-gray-100 active:bg-gray-200"
  >
    <!-- コンテンツ -->
  </div>
</template>
```

## Supabase 実装ガイドライン

### クライアント設定

#### 1. サーバーサイド用クライアント

```typescript
// server/utils/supabase.ts
import { createClient } from '@supabase/supabase-js'
import type { Database } from '~/types/supabase'

const supabaseUrl = process.env.NUXT_SUPABASE_URL || ''
const supabaseKey = process.env.NUXT_SUPABASE_KEY || ''

export const supabase = createClient<Database>(supabaseUrl, supabaseKey)
```

#### 2. Nuxt での Supabase の設定

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: [
    '@nuxtjs/supabase'
  ],
  supabase: {
    redirect: {
      login: '/auth/login',
      callback: '/auth/confirm',
      exclude: ['/']
    }
  }
})
```

#### 3. 型安全なクエリ

```typescript
// 自動生成された型定義を使用
import type { Database } from '~/types/supabase'
type User = Database['public']['Tables']['users']['Row']

// クエリの例
const { data, error } = await supabase
  .from('users')
  .select('id, name, email')
  .eq('id', userId)
  .single()
```

### Row Level Security (RLS) の実装

#### 1. 認証ユーザー専用テーブル

```sql
-- テーブル作成
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  name TEXT,
  avatar_url TEXT,
  updated_at TIMESTAMP WITH TIME ZONE
);

-- ポリシー設定
-- 自分のプロフィールだけ閲覧可能
CREATE POLICY "Users can view own profile" 
ON profiles FOR SELECT 
USING (auth.uid() = id);

-- 自分のプロフィールだけ更新可能
CREATE POLICY "Users can update own profile" 
ON profiles FOR UPDATE 
USING (auth.uid() = id);
```

#### 2. 公開/非公開データのポリシー

```sql
-- 記事テーブル
CREATE TABLE articles (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  author_id UUID REFERENCES auth.users(id),
  is_published BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 公開記事は誰でも閲覧可能
CREATE POLICY "Anyone can view published articles" 
ON articles FOR SELECT 
USING (is_published = TRUE);

-- 未公開記事は作者のみ閲覧可能
CREATE POLICY "Authors can view own unpublished articles" 
ON articles FOR SELECT 
USING (auth.uid() = author_id AND is_published = FALSE);

-- 記事の更新は作者のみ可能
CREATE POLICY "Authors can update own articles" 
ON articles FOR UPDATE 
USING (auth.uid() = author_id);
```

#### 3. ロールベースのアクセス制御

```sql
-- ユーザーロールテーブル
CREATE TABLE user_roles (
  user_id UUID REFERENCES auth.users(id),
  role TEXT NOT NULL,
  PRIMARY KEY (user_id, role)
);

-- 管理者の場合はすべての記事を編集可能
CREATE POLICY "Admins can update any article" 
ON articles FOR UPDATE 
USING (
  EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid() AND role = 'admin'
  )
);
```

### リアルタイム機能の活用

```typescript
// composables/useRealtimeMessages.ts
import { ref, onUnmounted } from 'vue'
import type { RealtimeChannel } from '@supabase/supabase-js'

export function useRealtimeMessages(chatId: string) {
  const messages = ref<Message[]>([])
  const supabase = useSupabaseClient()
  let subscription: RealtimeChannel
  
  const fetchMessages = async () => {
    const { data } = await supabase
      .from('messages')
      .select('*')
      .eq('chat_id', chatId)
      .order('created_at', { ascending: true })
    
    if (data) messages.value = data
  }
  
  const subscribeToMessages = () => {
    subscription = supabase
      .channel('messages')
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'messages',
        filter: `chat_id=eq.${chatId}`
      }, (payload) => {
        messages.value.push(payload.new as Message)
      })
      .subscribe()
  }
  
  // 初期データロードとサブスクリプション開始
  fetchMessages()
  subscribeToMessages()
  
  // クリーンアップ
  onUnmounted(() => {
    subscription?.unsubscribe()
  })
  
  return { messages }
}
```

## セキュリティ対策

### 1. 環境変数管理

- `.env` ファイルは絶対にGitHubにコミットしない
- `.gitignore` に `.env*` を必ず追加
- 環境変数は以下の種類に分類
  - `NUXT_PUBLIC_` プレフィックス: クライアント側に公開可能な変数
  - `NUXT_` プレフィックス: サーバーサイドのみで使用する機密変数

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  runtimeConfig: {
    // サーバーサイド専用の機密変数
    apiSecret: process.env.API_SECRET,
    supabaseServiceKey: process.env.NUXT_SUPABASE_SERVICE_KEY,
    
    // クライアント側に公開可能な変数
    public: {
      apiBase: process.env.NUXT_PUBLIC_API_BASE,
      supabaseUrl: process.env.NUXT_PUBLIC_SUPABASE_URL
    }
  }
})
```

### 2. 認証とセキュリティ

#### Supabase認証
- 常にサーバーサイドで認証トークンを検証
- クライアントサイドでは短命のセッショントークンを使用
- パスワードリセット、多要素認証を実装

```typescript
// server/middleware/auth.ts
export default defineEventHandler(async (event) => {
  // 認証不要なルートはスキップ
  if (isPublicRoute(event.path)) return
  
  const supabase = serverSupabaseClient(event)
  const { data: { session } } = await supabase.auth.getSession()
  
  if (!session) {
    throw createError({ 
      statusCode: 401, 
      message: '認証が必要です' 
    })
  }
})
```

#### パスワードポリシー
- 最小長さ: 12文字以上
- 複雑性要件:
  - 大文字
  - 小文字
  - 数字
  - 特殊文字
- パスワードハッシュは常にサーバーサイドで処理

### 3. 入力バリデーション

- サーバーサイドとクライアントサイドの両方でバリデーション
- zod または valibot を使用した型安全なバリデーション

```typescript
import { z } from 'zod'

// 登録フォームのスキーマ
